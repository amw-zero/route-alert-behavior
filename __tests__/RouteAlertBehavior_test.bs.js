// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var RouteAlertBehavior = require("../src/RouteAlertBehavior.bs.js");

function googleDurationEncoder(googleDuration) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "value",
                googleDuration.value
              ],
              /* [] */0
            ]);
}

function googleLegEncoder(googleLeg) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "duration_in_traffic",
                googleDurationEncoder(googleLeg.duration)
              ],
              /* [] */0
            ]);
}

function googleRouteEncoder(googleRoute) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "legs",
                Json_encode.list(googleLegEncoder, googleRoute.legs)
              ],
              /* [] */0
            ]);
}

function googleDirectionsEncoder(googleDirections) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "routes",
                Json_encode.list(googleRouteEncoder, googleDirections.routes)
              ],
              /* [] */0
            ]);
}

function serverNetworkBridge(request, respond) {
  var pathString = String(request.path);
  if (pathString.includes("maps.googleapis.com")) {
    return Curry._1(respond, googleDirectionsEncoder({
                    routes: /* :: */[
                      {
                        legs: /* :: */[
                          {
                            duration: {
                              value: 6
                            }
                          },
                          /* [] */0
                        ]
                      },
                      /* [] */0
                    ]
                  }));
  } else {
    return 0;
  }
}

function clientNetworkBridge(request, respond) {
  var match = request.path;
  if (match === "/route_alerts") {
    var match$1 = request.body;
    if (match$1 !== undefined) {
      return RouteAlertBehavior.createRouteAlertEffectHandler(Caml_option.valFromOption(match$1), serverNetworkBridge, Curry.__1(respond));
    } else {
      return Curry._1(respond, RouteAlertBehavior.errorResponseEncoder({
                      message: "bad body"
                    }));
    }
  } else {
    return Curry._1(respond, RouteAlertBehavior.errorResponseEncoder({
                    message: "bad route"
                  }));
  }
}

var testEnv = {
  networkBridge: clientNetworkBridge
};

function reduceActions(actions) {
  var state = {
    contents: RouteAlertBehavior.initialState
  };
  return Belt_List.reduce(actions, RouteAlertBehavior.initialState, (function (param, action) {
                RouteAlertBehavior.Reffect.makeDispatch(state.contents, RouteAlertBehavior.reducer, testEnv, (function (s) {
                          state.contents = s;
                          return /* () */0;
                        }))(action);
                return state.contents;
              }));
}

function canFetch(state) {
  if (state) {
    return false;
  } else {
    return true;
  }
}

function createRouteAlert($staropt$star, $staropt$star$1, $staropt$star$2, param) {
  var minutes = $staropt$star !== undefined ? $staropt$star : 5;
  var origin = $staropt$star$1 !== undefined ? $staropt$star$1 : "origin";
  var dest = $staropt$star$2 !== undefined ? $staropt$star$2 : "dest";
  return /* :: */[
          /* SetOrigin */Block.__(0, [origin]),
          /* :: */[
            /* SetDestination */Block.__(1, [dest]),
            /* :: */[
              /* SetMinutes */Block.__(2, [minutes]),
              /* [] */0
            ]
          ]
        ];
}

Jest.describe("Route Alert Behavior", (function (param) {
        Jest.test("preventing alert creation when all data is not present", (function (param) {
                var state = reduceActions(/* :: */[
                      /* SetOrigin */Block.__(0, ["origin"]),
                      /* :: */[
                        /* SetDestination */Block.__(1, ["dest"]),
                        /* [] */0
                      ]
                    ]);
                return Jest.Expect.toBe(false, Jest.Expect.expect(state.routeFetchAbility ? false : true));
              }));
        Jest.test("preventing alert creation when all data is present", (function (param) {
                var state = reduceActions(createRouteAlert(undefined, undefined, undefined, /* () */0));
                return Jest.Expect.toBe(true, Jest.Expect.expect(state.routeFetchAbility ? false : true));
              }));
        Jest.test("calculating route duration when calculation is successful", (function (param) {
                var state = reduceActions(List.flatten(/* :: */[
                          createRouteAlert(undefined, undefined, undefined, /* () */0),
                          /* :: */[
                            /* :: */[
                              /* FetchRoute */0,
                              /* [] */0
                            ],
                            /* [] */0
                          ]
                        ]));
                var passed = function (param) {
                  if (param !== undefined) {
                    return param === 6;
                  } else {
                    return false;
                  }
                };
                return Jest.Expect.toBe(true, Jest.Expect.expect(passed(state.routeDuration)));
              }));
        Jest.test("creating link to route in Google maps when there are no spaces in the stops", (function (param) {
                var state = reduceActions(/* :: */[
                      /* SetOrigin */Block.__(0, ["origin"]),
                      /* :: */[
                        /* SetDestination */Block.__(1, ["dest"]),
                        /* [] */0
                      ]
                    ]);
                return Jest.Expect.toBe("https://google.com/maps/dir/origin/dest", Jest.Expect.expect(state.routeLinkGoogle));
              }));
        return Jest.test("creating link to route in Google maps when the stops have spaces", (function (param) {
                      var state = reduceActions(/* :: */[
                            /* SetOrigin */Block.__(0, ["new york"]),
                            /* :: */[
                              /* SetDestination */Block.__(1, ["new jersey"]),
                              /* [] */0
                            ]
                          ]);
                      return Jest.Expect.toBe("https://google.com/maps/dir/new+york/new+jersey", Jest.Expect.expect(state.routeLinkGoogle));
                    }));
      }));

exports.googleDurationEncoder = googleDurationEncoder;
exports.googleLegEncoder = googleLegEncoder;
exports.googleRouteEncoder = googleRouteEncoder;
exports.googleDirectionsEncoder = googleDirectionsEncoder;
exports.serverNetworkBridge = serverNetworkBridge;
exports.clientNetworkBridge = clientNetworkBridge;
exports.testEnv = testEnv;
exports.reduceActions = reduceActions;
exports.canFetch = canFetch;
exports.createRouteAlert = createRouteAlert;
/*  Not a pure module */
